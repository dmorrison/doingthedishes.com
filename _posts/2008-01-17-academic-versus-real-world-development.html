--- 
layout: default
title: Academic Versus Real World Development
---
<p>I think I've decided to take a break from my graduate course work at Auburn. I had a terrible time with the class I took last Fall (Formal Methods for Software Engineering) and this has discouraged me from continuing with school.</p>  <p>Not that I needed a big push, on the one hand: it's hard to work a regular job and have the discipline to come home and watch classes during the week, do regular homework and class projects, take exams, etc. And it can seem difficult to try to push yourself to learn seemingly abstract concepts that might not be directly applicable to the current technology you're using at work. [more]</p>  <p>However, hopefully I'm not being lazy and whiney. The formal methods class I took was about logically proving programs to be correct. In it, we learned a specification language called &quot;Z&quot; and tried to prove, using logical axiomatic systems, trivial programs that took many hours of thought and many pages of notes to prove. This is an interesting concept, but currently it seems not to be held as a very useful thing in software engineering practice. There are only a handful of mostly specialized examples of applications that I came across while taking the class, and I didn't really find any modern tools that use this in practice. Given this probably biased description of the class, it's probably easy to see the friction I felt while doing my course work at night, and trying to solve &quot;real world&quot; software engineering problems in the day at work.</p>  <p>Coincidentally, I saw several blog entries pop up in my feed reader towards the end of last year that seemed to express this same sentiment. Famed blogger <a href="http://www.joelonsoftware.com/">Joel Spolsky</a>, in a <a href="http://www.joelonsoftware.com/items/2007/12/03.html">talk</a> given to the computer science department at Yale, had this to say about the best course in computer science he ever took:</p>  <blockquote>   <p>I worked on that problem for hours and hours. I had her original proof in front of me, going in one direction, which, upon closer examination, turned out to have all kinds of missing steps that were &#8220;trivial,&#8221; but not to me. I read every word about Dynamic Logic that I could find in Becton, and I struggled with the problem late into the night. I was getting absolutely nowhere, and increasingly despairing of theoretical computer science. It occurred to me that when you have a proof that goes on for pages and pages, it&#8217;s far more likely to contain errors in the proof as our own intuition about the trivial statements that it&#8217;s trying to prove, and I decided that this Dynamic Logic stuff was really not a fruitful way of proving things about actual, interesting computer programs, because you&#8217;re more likely to make a mistake in the proof than you are to make a mistake in your own intuition about what the program &#8220;f := not f&#8221; is going to do. So I dropped the course, thank God for shopping period, but not only that, I decided on the spot that graduate school in Computer Science was just not for me, which made this the single most useful course I ever took. </p> </blockquote>  <p>ASP.NET developer and blogger <a href="http://haacked.com/">Phil Haack</a> related <a href="http://haacked.com/archive/2007/11/16/what-exactly-are-you-trying-to-prove.aspx">an experience he had in college</a> solving math problems with the importance of testing in software practice versus provability:</p>  <blockquote>   <p>...trying to prove the correctness of computer programs is a lot like trying to solve a set of partial differential equations. It works great on small trivial programs, but is incredibly hard and costly on anything resembling a real world software system.</p> </blockquote>  <p>And, most recently, .Net developer <a href="http://ayende.com/Blog/Default.aspx">Oren Eini</a> also commented on <a href="http://ayende.com/Blog/archive/2008/01/12/Academia-in-Real-World-Development.aspx">the appropriateness of using academic knowledge in the field</a>:</p>  <blockquote>   <p>Finding a path in a graph? Design a compiler? Analyzing an image? Choosing a search algorithm? Selecting appropriate data structure for a task?</p>    <p>For each of those I would head for the academia, directly. Those are technical issues, and I want the academic proofs and experience there. I want the mathematical foundation for the solution. </p>    <p>Designing a maintainable system? Building a usable framework? Creating the domain model? </p>    <p>For those I am going to not going to go to the academia. I am going to go to the real world practitioner. They guys (and gals) that have been burned in the field and learned from their mistakes.</p> </blockquote>  <p>I don't think the graduate level CS courses are totally useless, by far, and I might even get the urge to continue my degree later, but for now, I'm going to focus on learning more practical technologies and drinking gently from the fire-hose of new languages, frameworks, and tools that are constantly being churned out of the interwebtubes.</p>
