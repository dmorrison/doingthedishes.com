--- 
layout: post
title: A Problem Unit Testing with .NET Private Accessors
---
<p>Recently I ran into a problem using .NET accessor methods to unit test private methods. I was able to resolve the problem, but in doing so ended up abandoning accessor methods in favor of a simpler approach (using reflection). </p>  <h3>But should you even test private methods?</h3> It's a nuanced question. On one hand, it seems reasonable to break a class into small, purposeful private methods (exposing the main points of the class publicly) but still test the smallest possible chunks of functionality by testing those private methods in addition to the public ones. On the other, testing only public methods should exercise those private methods enough, and testing private methods can make your test code more brittle to change. There's a good table <a href="http://www.codeproject.com/KB/cs/testnonpublicmembers.aspx">here</a> with more arguing points.   <p>For my purposes, I decided that I should.</p>  <h3>What's a private accessor method?</h3>  <p>But how do you get at privates? The default .NET unit test suite (MSTest) provides a seemingly handy facility within Visual Studio to easily do this by generating so called &quot;private accessors&quot;.&#160; </p>  <p>Just right click on a private method in your code like so</p>  <p><img src="http://docs.google.com/File?id=dhj8dxgf_208cv3r43f2_b" /></p>  <p>then click &quot;Create Private Accessor&quot; and point it to a project containing your test code. and the tool magically provides proxy types (with the suffix &quot;_Accessor&quot;) that expose these private methods publicly and that you can use from within your unit tests to access these private members like this:</p>  <code> var myObject = new MyClass_Accessor();<br /> var result = myObject.PrivateMethod(); </code>  <p>How useful, right?</p>  <h3>A problem</h3>  <p>I ran into trouble when I had a private method that returned a generic list of private classes. When I generated an accessor for the method, an accessor for the private class was also generated so that the accessor method actually returned a list of &quot;MyPrivateClass_Accessor&quot; types instead of &quot;MyPrivateClass&quot; types.</p>  <p>This generated code actually gives an error, and <a href="http://social.msdn.microsoft.com/Forums/en-US/vststest/thread/6ee0766f-329a-464f-a526-f89accca4f07/">seems</a> to be a bug in Visual Studio 2008. MyPrivateClass_Accessor derives from MyPrivateClass, and while you can cast a derived class to its base class, in .NET you can't cast a list of derived classes to a list of its base classes (as I assume it's doing internally in the generated code).</p>  <p>I suppose they're working to fix this.</p>  <h3>A simpler alternative</h3>  <p>Using a bit of code (good samples are available <a href="http://www.codeproject.com/KB/cs/testnonpublicmembers.aspx">here</a> and <a href="http://melgrubb.spaces.live.com/blog/cns!A44BB98A805C8996!235.entry">here</a>) that uses reflection and extension methods, you can still fairly easily test these methods like so:</p>  <code> var myObject = new MyClass();<br /> var result = (List&lt;MyPrivateClass&gt;) myObject.CallMethod(&quot;PrivateMethod&quot;); </code>  <p>Sure, there's extra casting work and you have to use nasty string literals for the method names, but this is test code after all, and if it breaks you should know quickly from a regular test run.</p>  <h3>A lesson</h3> One of the hazards, it seems, working with Microsoft tools is the strong focus on tooling itself. This can sometimes get in the way of more elegant solutions based on simpler principles.   <p>Not that all or most of the tools are bad (a lot of them I feel make me more productive), but it's a glamorous trap that you should be aware of.</p>
